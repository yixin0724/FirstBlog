---
title: 刷题记录
date: 2024-10-24 10:02:18
tags: 
  - 算法
cover: https://pic.imgdb.cn/item/6719abccd29ded1a8c71be73.jpg
categories: 实践记录
description: 记录一下力扣上做过的编程题。
---







# 题1

​	题号：3175

​	题目：找到连续赢K场比赛的第一位玩家

​	难度：中等

```java
/**
 * 比赛规则，每个人的技能等级互不相同，获胜者保持在队列的开头，而失败者排到队列的末尾。
 * 思路
 * 从规则可知胜者一定是队头的
 * 题目不需要返回队列，因此可以不用重新排序，因极端情况胜者在最后一位需要对第一个进行比较，此时可以对长度取余，防止越界。
 * 看测试案例可知这个k非常大，所以只需要对数组遍历一遍，如果还没找出胜者，那此时队头指针指向的一定是最大的那个。
 * 这种方法只需返回队头指针指向的索引即可
 *
 * 具体实现
 * 采用双指针控制比较的对象，初始化对头指针为0，比较对象j为1
 * while循环进行比较指针指向的两个人，循环结束条件是队头的人达到了k个胜场。
 * 每当队列开头的人更换时，胜场就要归为1。
 *
 * 时间复杂度：O(n)，其中n是数组的长度。
 * 空间复杂度：O(1)
 */
class Solution {
    public int findWinningPlayer(int[] skills, int k) {
        int winCount = 0;	//胜场
        int i = 0;	//队头
        int j = 1;	//待比较对象
        int count = 0;  //记录遍历次数，当最后一个玩家比较完后，直接返回队头指针指向的索引
        int len = skills.length;
        //循环结束条件，胜场没达到，且还没遍历完一遍
        while (winCount < k && count <= len) {
            if (skills[i] > skills[j]) {
                //当队头大于被比较的对象时，j+1，且胜场+1
                j = (j + 1) % len;
                winCount++;
            } else {
                //即队头小于被比较的对象，此时要保持队头指向大的，同时胜场要归为1
                i = j;
                j = (j + 1) % len;
                winCount = 1;
            }
            //count记录遍历次数
            count++;
        }
        //返回队头指针指向的索引
        return i;
    }
}
```

