---
title: C++基础
date: 2024-10-08 10:12:40
tags: 
  - C++
  - 编程语言
cover: https://pic.imgdb.cn/item/670495d8d29ded1a8c170dd0.jpg
categories: 技术记录
description: 在科大做HPC相关方向的东西，重新回顾一下C++！
---







# C++17

## 常用

```
①
②clion每个工程只允许一个main，所以在创建c++源文件的时候，不要将他添加到CMakeLists.txt即可
③数组长度：sizeof(arr)/sizeof(arr[0])
```





## 前言

### 头文件

```
#include "iostream"			//c++输入输出库
#include<bits/stdc++.h>		//万能头文件
#include<vector>
#include<cstdio>  		//结合c语言的c++输入输出库，推荐算法使用这个printf和scanf
#include<string>
#include "cstring"		//字符串库

using namespace std;	//命名空间
```



### 编译

​	概述：就是将cpp文件的代码编译成计算机可执行的exe文件。

​	编译器：mingw(即gcc在window平台的版本)

​	手动编译命令：g++ 文件名.cpp -o 文件名.exe







## 基础语法

### 输入和输出

#### cout

​	作用：帮助将内容打印到控制台上

​	使用：cout<<内容;

​	换行：<<endl; 

​	输出多份内容：可以通过多个 << 进行自由组合输出内容。

中文输出乱码解决

​	方法一：

​		引入windows.h库，即#include "windows.h"

​		使用SetConsole0utputCP("CP_UTF8");	//修改控制台输出编码格式

​	方法二：

​		直接添加system("chcp 65001");		//表示将控制台输出编码改为65001也就是utf8



#### cin

​	作用：完成从键盘输入数据提供给运行的程序

​	语法：cin >> 变量; 	//输入数据对变量赋值

​	中文乱码解决：在clion中按下Ctrl + Alt + Shfit + / 四个键，选择注册表，把run那个取消掉





### 注释

​	单行注释：// 内容

​	多行注释：/* 内容 */



### 常量

​	概述：在程序执行过程中值不会改变的量。

​	常量类型的决定：在C++中，对于常量的类型确定遵循最小原则

![](../../../Users/作业/知识点/编程语言/c/图片/常量1.png)

​	按照所书写的字面量的值，来确定类型，默认int,从小到大进行适配

​	或按照指定后缀确定，后缀大小写都可以，常用的，U、L、UL、ULL(unsigned long long)、F、D(double)

​	

#### 字面常量

​	概述：被书写到代码内的常量称之为字面常量，也称字面量。

​	整型字面常量：整数，不带小数点的数字

​	实型字面常量：小数，带有小数点的数字

上述两种叫做数值型常量

​	字符型字面常量：以单引号' '包围的，单个字符

​	字符串字面常量：以双引号" "包围的，任意个字符

#### 符号常量

​	概述：使用标识符去定义的常量，称之为符号常量。简单来说，符号常量就是给常量起一个名字，就是符号常量。

​	定义语法：#define  标识符(名称)  常量		//这个#define是宏命令，标识符即符号常量的名称，建议全部大写

​	例如：#define FAT_ BMI 28 	//肥胖BMI，因为经常使用这个常量，所以使用这种方法定义

​	注意：

​		①定义在代码的头部

​		②不需要添加分号结尾

​		③满足标识符的要求下，字母全部大写







### 标识符

​	概述：即表示某类实体的符号(名称)。

​	比如：符号常量名、变量名、类名称、文件名、方法/函数名等等，都是标识符。

​	内容限定：

​		①只允许字母、数字、下划线的组合，数字不可开头

​		②大小写敏感

​		③不可以是关键字

​	常用命名规范：

​		下划线命名法：字母一般全小写，单词之间用下划线隔开。一般应用于变量名

​		小驼峰命名法：首单词首字母小写，其他单词首字母大写。一般应用于函数名，变量名

​		大驼峰命名法：单词首字母全部大写。一般应用于类名

​	



### 关键字

​	概述：在c++内具有特殊意义的单词





### 变量

​	概述：在程序运行时，能储存计算结果或能表示值的抽象概念。简单的说，变量就是在程序运行时，记录数据用的。

​	定义变量语法：变量类型  变量名;

​	变量赋值语法：变量名 = 变量值;

​	常见的变量类型：

```
支持一次性声明多个变量，例如：
int a,b,c;
int a=10,b=20,c=30;
```



#### 变量的作用域

​	{...   ...}称之为代码块，也是内部变量的作用域，在{}内部声明的变量，只能在内部使用

​	作用域可以向内层的{}进行传递，但是外部是无法访问到的





### 数据类型

#### int

​	int即整型，整型分为4种如下：

![](../../../Users/作业/知识点/编程语言/c/图片/整型1.png)

​	可以使用sizeof(变量名)查看占用空间大小



##### 无符号和有符号数字

​	无符号：仅仅允许正数存在

​	有符号：可以允许负数存在

![](../../../Users/作业/知识点/编程语言/c/图片/有无符号数字.png)

上述图中的[ ]表示可选，且默认时就代表有符号

无符号的快捷写法：

​	u_int 变量名 = 0；	//其他同理





#### float

​	float即实型。还分为3种

![](../../../Users/作业/知识点/编程语言/c/图片/实型1.png)

​	实型数据全部都是有符号的，并且不同编译器有效位不一样。

​	注意有效位数，超出了就会不准确，小数点也占一位

```
输出控制小数格式
cout << fixed;  //设置为小数显示
cout.width(20);   //设置显示的最大宽度(最大位数)
cout << num1 << endL ;
```



#### char

​	char即字符型。

![](../../../Users/作业/知识点/编程语言/c/图片/字符型1.png)

char型的本质是数字，在内存中是以数字存储的，以ASCII码表转换。

97是a，65是A。并且字符可以进行数字加减。



#### string

​	string即字符串型。

​	C语言风格的字符串，如下：

​		char a[] = "hello";	//字符数组形式，不可更改变量值

​		char *b = "hello";	// 指针形式

​	C++风格的字符串

​		string c = "hello";



字符串拼接

​	方法一：可以直接使用 + 进行连接，但+号只适用于字符串和字符串的连接。可以使用to_string()内置函数将内容转换位字符串



#### boolean

​	布尔值只有true和fasle，本质是1和0





### 转义字符

​	\就是转义符号

​	ASCII表中字符分为两类：非打印控制字符、打印字符

​	非打印控制字符：无法打印出形态，但是可以用于表示各种控制功能，如换行、制表等

​	\t可以将前面的字符以空格填充的形式，补充至8个字符位

![](../../../Users/作业/知识点/编程语言/c/图片/转义字符.png)





### 运算符

#### 算数运算符

![](../../../Users/作业/知识点/编程语言/c/图片/算数运算符.png)



#### 赋值运算符

​	概述：是一种双目运算符，用于将右侧表达式的值赋予左侧变量。

![](../../../Users/作业/知识点/编程语言/c/图片/赋值运算符.png)



#### 比较运算符

​	概述：是一种双目运算符，用于对两个数据进行比较(大、小、相等) ，得到bool型结果。

​	c语言风格的字符串，比较的是内存地址。可以使用cstring库中的strcmp(s1，s2)方法是比较两个字符串的内容，返回-1，0，1

​	c++风格的字符串可以直接比较内容

![](../../../Users/作业/知识点/编程语言/c/图片/比较运算符.png)



#### 逻辑运算符

​	概述：是一种单/双目运算符，用于对单个或多个表达式进行逻辑判断。

![](../../../Users/作业/知识点/编程语言/c/图片/逻辑运算符.png)



#### 三元运算符

​	概述：是一种三目运算符，用于对逻辑进行判断，根据判断结果提供不同值。

​	语法：产出bool结果的表达式 ? 值1 : 值2;

​	含义：如果?之前的表达式结果为true，那么提供值1的结果，如果结果为false，那么提供值2的结果



#### 位运算符





### 判断语句

#### if

#### if-else

#### if-else if



### 控制语句

#### switch

​		格式：switch（表达式）{

​						case 常量表达式1：

​							语句体1；

​							break；

​						case 常量表达式2：

​							语句体2；

​							break；

​						....

​						default：

​							语句体n+1；

​							break；

​					}

​		注意事项：

​			①default是前面所有结果不匹配后，就会进行这个，他可省略，并且可在任何位置。

​			②case后面只能是字面量或者枚举类型，不能是变量，且不能重复。



### 循环语句

#### for

#### while

#### do-while



### 枚举类型

​	概述：本质上是一个被命名的整型常数的集合。在C\C++语言中它是种基本数据类型 。

​	作用：提高代码的可读性、可维护性和键入性。因为枚举可以将一些数字或字符串符号化，以此增强程序的可读性和可维护性。

```
语法：
enum枚举名{
	枚举元素1,
	枚举元素2,
	...
	枚举元素n
};

例如：
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER
};
Season v1 = SPRING;
Season v2 = WINTER;

枚举类型每一个元素，都有整数标号，默认从0开始递增。即上述代码SPRING本质是数字0，SUMBER是2,以此类推。
起始标号可以自行设置，如下:
enum Season {
    SPRING = 3
    SUMMER,
    AUTUMN,
    WINTER
};		//从3开始递增，即: SPRING为3、SUMMER为4、AUTUMN为5、WINTER为6

一般和switch一起使用
```







### 中断语句

#### break

#### continue

#### goto

​	作用：提供无条件跳转功能

​	语法：

​		标记名字:

​		goto 标记名字;







### 数组

​	概述：是由一批相同类型的元素( eLement)的集合所组成的数据结构。分配一块连续的内存去存储

​	语法：数据类型  数组名[数组长度];

```
特点：
    ①任意数据类型都能创建数组
        基本数据类型: int、fLoat、 double、 char、string、 boolL等
        复合数据类型：结构体、联合体等
        指针类型: int*、 char*、 fLoat*等
        枚举类型: enum
    ②数组一旦定义，大小即长度就固定了
    ③内存连续且有序
    ④通过sizeof(数组)获取元素个数
    ⑤元素值可以修改
    ⑥数组对象记录的是索引为0的地址。
数组对象本身就是引用数据类型，即可以看作指针
```

​	静态赋值：int v[] = {1,2,3};

​	遍历：使用for或者while



#### 字符数组

​	c语言风格定义的字符串，本质就是一个字符数组：

​		表现一："he"

​		表现二：char s[] = "he";

​		均可以表现为：char s[] = {'h','e', '\0'};

​	上述2种C语言风格字符串，其存储机制：将每一个字符，作为1个元素，存入字符数组中。在字符数组中，额外在最后添加一个元素\0 (空字符) ，作为结束标记。

​	注意：中文一定要使用string类型，不要用char数组。



#### 多维数组

​	概述：对数组进行嵌套，即数组内的每个元素依旧是数组。

​	二维数组定义：`int v[3][3];`

```
遍历二维数组：
for(int i=0; i < sizeof(v1) / sizeof(v1[0]); i++){
    for (int j=0; j < sizeof(v1[0]) / sizeof(v1[0][0]); j++){
		cout << v1[i][j] << endL;
	}
}
```





#### 数组元素的移除

​	前景：C++内置并未提供对数组元素进行增加(插入)、移除的功能，需要手动实现(vector容器提供)。

​	实现：

​		1.通过new操作符，申请新数组的内存空间，并复制数据到新数组

​		2.通过delete删除旧数组的空间占用

​		3.将旧数组指针，指向新数组地址

​	本质：是将需要的元素复制到了一个新的数组















### 指针

​	概述：特定类型数据在内存中的存储地址，即内存地址。指针只是一个逻辑概念，其实际应用是：指针变量

​	指针变量：即变量p存储了一个变量的地址。并且指针变量本身也有自己的存储地址

​	本质：协助程序员完成内存的直接操纵

​	指针也可以像数组那样使用索引，p[0] = *(p+0)

```
定义方法一：先声明，后赋值
	变量类型 *指针变量名;	//声明
	指针变量名 = 内存地址值;	//赋值
	不推荐，尽量处初始化为空
例如：
    int num = 10;
    int *p;
    p = &num;	//&在这里是取地址
    cout << p;	//输出num变量地址
    cout << *p;	//输出num变量值
定义方法二：声明和赋值同步
	变量类型 *指针变量名 = 内存地址值;
	
*符号有两种含义:
	声明时：*p，表示变量p，是指针变量(存的是内存地址)
	使用时：*p，表示取指针p执行内存区域的数据。
&符号表示取变量内存地址，是一个取内存地址的单目操作符。


野指针：被声明但未初始化(赋值)的指针。这个指针会指向随机的内存空间，可能导致未知问题。(声明即分配内存原则)
为避免野指针，应及时初始化，或将指针置为空指针更为安全。
	int *p = NULL;
	int *p = nullptr;
NULL是C++内置的宏，表示"空、什么都没有"的含义，其本质是0
nuLLptr是C++11标准引入的关键字，表示指针为空
```





#### 指针运算

```
指针进行加减运算的结果，和指针指向内存区域的数据类型有关，以加法为例: 
    char类型指针+1,地址+1(字节)
    int类型指针+1，地址+4(字节)
    doubLe类型指针+1，地址+8(字节)
    指针+n或-n，即内存地址 +n*类型大小 或 -n*类型大小
```





#### 指针悬挂

​	概述：指针指向区域已经被回收(deLete)，这种问题称之为指针悬挂。

​	表现：指针悬挂之后，所指向的值是随机不确定的。容易造成内存安全问题。

​	解决方法：

​		不要轻易进行指针之间相互赋值

​		deLete回收空间前，确保此空间100%不再被使用



#### 常量指针

​	被const修饰的指针就叫常量指针。

​	共分为已下3中类型的：

​	①指向const的指针：表示指向区域的数据，是不变的，但可以更换指向。

​		语法：const  数据类型 *指针;  或者   数据类型 const *指针;

​		只需确保const在*前面即可。

​		该类型的也就是只能指向常量也就是const

​	②const指针：表示指针本身不可更改，但指向的数据可以更改。

​		语法：  数据类型 * const 指针 = 地址; 	//必须初始化地址，因为地址不可修改

​	③指向const的const指针：指针和指向区域的值，都不可更改。

​		语法：const 数据类型 * const 指针 = 地址;	//必须初始化地址，因为地址不可修改

​	使用场景：

​		①需要常量的同时也需要动态内存分配的场景

​		②因为只有使用指针，方可动态分配内存







### 动态内存分配

​	概述：即由程序员手动的进行内存空间的分配、内存空间的释放等内存管理操作。

​	前景：

​		C++代码中，变量、数组等对象的创建，是由C++自动分配内存的，称之为(自动)静态内存分配。

​		(自动)静态内存管理，是不会进行内存空间的自动清理的。 (无垃圾回收机制)。

​		我们需要手动的管理内存，即手动分配，用完清理。

#### new

​	概述：new运算符用于申请并分配内存空间，并提供指向该空间的指针(内存地址)

​	基本语法：

​		new type   //申请普通变量空间

​		new type[n]   //申请数组空间

#### delete

​	概述：delete运算符用于释放内存，仅可用于new运算符申请的内存区域

​	基本语法：

​		delete 指针    //删除普通变量空间

​		delete[]  指针    //删除数组空间

注意：常量是不需要删除的，main函数执行完会自动清理。









### 结构体

​	概述：结构体(struct) ,是一种用户自定义复合数据类型，可以包含不同类型的不同成员。

```
语法如下：
//声明结构体
struct 结构体类型
{
	成员1类型 成员1名称;
	....
	成员N类型 成员N名称;
};

struct 结构体类型 结构体变量名称;  //定义结构体变量(struct关键字可省略)
结构体变量名称.成员名称   //访问结构体成员变量
结构体变量名称 = {赋值1，赋值2....}

默认值
	可以在定义的时候直接赋值，代表的意思就是如果不手动赋值，就会默认使用这个值
```



#### 结构体数组

​	作用：将自定义的结构体放入到数组中方便维护

​	创建：struct  结构体名   数组名[元素个数]  =  { {}，{}，...{} }

​	建议使用new进行动态赋值



#### 结构体指针

​	作用：通过指针访问结构体中的成员

​	利用操作符 ->  可以通过结构体指针访问结构体属性

```
应用一：引入已经存在的结构体变量地址
struct Student *p = &stu;	//直接将存在的结构体变量的地址赋值给指针，这种方法没法回收空间
struct Student *p = new Student{"1",2,3};	//这种能回收空间

示例：
//1、创建学生结构体变量
students = {”张三”，18，100 };
//2、通过指针指向结构体变量
student *p = &students;
printf("%students",p->name)
```





#### 结构体嵌套结构体

​	作用：结构体中的成员可以是另一个结构体

​	示例：

```
例如:每个老师辅导一个学员, 一个老师的结构体中,记录一个学生的结构体
//学生结构体定义
struct student
{
    string name; //姓名
    int age;	//年龄 
    int score;	//分数
};

//定义老师结构体
struct teacher{
    int id; //教师编号
    string name; //教师姓名
    int age; //年龄
    struct student stu; //辅导的学生
};
//创建老师
teacher t;
t.id = 10000;
t.name =”老王”;
t.age = 50;
t.stu.name =”小王”;
t.stu.age = 20;
t.stu.score = 60;
```





#### 结构体作为参数

​	作用：将结构体作为参数向函数中传递

​	传递方式有两种:

​		①值传递(不会影响原本的值)

​		②地址传递(会跟着形参的改变而改变)		#定义的时候传入struct student *p，使用的时候传入&s1。用->访问内部属性

​	注意：使用地址传递，可以通过const防止内部属性得到修改。









### 函数

​	概述：是一个提前封装好的、可重复使用的、完成特定功能的独立代码单元。

​	定义同java一样

​	函数传参分为：值传递、地址传递、引用传递





#### 参数的值传递

​	值传递会复制值，无法对实参本身产生影响



#### 地址传递

​	地址传递会复制地址，对实参本身可以产生影响，但指针写法麻烦

​	比如指针，数组等

​	传入数组一般建议附带数组长度的传入，因为C++不会检查数组的内存边界。

```
例如交换两个变量的值
void switch_num(int *a, int *b){
    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}
```



#### 引用传递

​	像普通变量那样操作，但对实参本身可以产生影响

​	使用&表示传递引用对象

```
例如交换两个变量的值
void switch_num(int &a, int &b){
    int tmp;
    tmp = a;
    a = b;
    b = tmp;
}
```



#### 返回指针

​	定义要用指针类型接收，return返回一个指针。

​	但是要注意函数中的局部变量会在函数执行完自动清理。

​	需要返回数组时，使用指针接收也是一样的。但不能返回一个局部创建的静态数组。用new动态分配的可以返回，或者全局的静态数组。









### 引用

​	概述：对已存在的变量的别名，对引用的各种操作等同于操作被引用变量本身。

​	语法：数据类型&  引用名  =  被引用变量;

​	注意事项：

​		1.引用对象创建后，不可更改(更改指向到其它内存区域)

​		2.因不可更改，所以引用必须初始化

​		3.因必须初始化，所以引用不可为空(不可修改)

​	场景：用于函数形参的声明(引用传参)和返回值使用





### static

​	static表示静态(将内容存入静态内存区域)，可以修饰变量和函数

​	当static修饰函数内部的变量时，可以延长其生命周期到整个程序运行周期。











## 进阶





























## 扩展

### vector

​	概述：向量，以顺序存储的线性表。vector为可变长数组动态数组，定义的vector数组可以随时添加数值和删除元素。

​	头文件：#include\<vector>

​	一维初始化：

```
vector<数据类型> a; //定义了一个名为a的一维数组,数组可以存储int/double/结构体等类型数据

//指定长度和初始值的初始化：
vector<int> v(n);// 定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]
vector<int> v(n, 1);// v[0] 到 v[n - 1]所有的元素初始值均为1
//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）
```

​	二维初始化：

```
//初始化二维均可变长数组
vector<vector<int>> array(M, vector<int>(N));//定义一个行为M，列为N的二维数组
for (int i = 0; i < M; ++i) {
	for (int j = 0; j < N; ++j) {
	cin >> array[i][j];
	}
}
```

​	添加元素到尾部：vector.push_back(值);  

​	获取元素数量：即长度，vector.size();  

​	删除最后一个数据：vector.pop_back()

​	是否为空，为空返回真，反之返回假：vector.empty()

​	返回首元素的地址：begin()

​	返回最后一个元素的后一个位置的地址：end()

​	将数据插到索引处，原本的要往后移：insert(vector.begin() + 索引，值)		//索引是从0开始

​	将索引处的数据删除掉：erase(vector.begin() + 索引)

​	排序：

```
vector<int> a(n + 1);
sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序
end()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此
begin()返回首元素的迭代器（通俗来说就是地址）
```



练习1

```
题目描述:一个数如果恰好等于它的各个因子(该数本身除外)之和，如6=3+2+1,那么称该数为“完数”;若因子之和大于该数，则称其为“盈数”。求出2到60之间的所有“完数”和“盈数”。
#include<iostream>
#include<vector>
#include<cstdio>
using namespace std;

int	Sum(int i) {
	int sum = 0;
	//首先先判断每一个数他的因子都有哪些，其次再考虑他们因子之和等于还是大于本身
	//因子也就是能被数本身整除的数，从1到n-1
	for (int j = 1; j < i; j++)
	{
		if (i%j == 0)
		{
			sum = sum + j;
		}
	}
	return sum;
}
int main() {
	vector<int> evec;	//完数
	vector<int> gvec;	//盈数
	for (int i = 2; i <= 60; i++)		//从2一直到60，依次判断是完数还是盈数
	{
		if (Sum(i) == i)			//若是完数，则添加到完数的数组
		{
			evec.push_back(i);
		}
		else if (Sum(i) > i) {		////若是盈数，则添加到盈数的数组
			gvec.push_back(i);
		}
	}
	for (int i = 0; i < evec.size(); i++)	//输出完数
	{
		printf(" %d", evec[i]);
	}
	return 0;
}
```







### 队列

​	特点：先进先出，对头出队，队尾入队

​	场景：公平的等待，广度优先遍历

​	头文件：#include\<queue>

​	定义：queue<数据类型> 队列名;

​	方法：

​		①push：入队

​		②pop：出队

​		③empty：判断是否为空

​		④front：队首元素





### 栈

​	特点：先进后出，栈顶top进出

​	头文件：#include\<stack>

​	定义：stack<数据类型> 栈名;

​	方法：

​		①size()：返回栈元素个数

​		②push()：加入元素到栈中

​		③pop()：弹出栈顶元素

​		④top()：获取栈顶元素的内容

​		⑤empty()：判空







### 递归

​	核心：如何把问题为n的规模用n-1的规模去表示

```
如：传统3根柱子n个盘子的汉诺塔问题
假设上面的n-1个小的盘子你能够从A柱移到任何柱子，那递归步骤如下：
①先将n-1个小的移动到B柱子，共F(n-1)规模次
②然后将A柱唯一一个大的移到C柱，1次
③最后再将B柱的n-1个盘子移到C柱子完成。F(n-1)规模次
即2*F(n-1) + 1;
```





















### Map

​	头文件：#include\<map>

​	初始化：map<数据类型, 数据类型> mp;	//数据类型如int，string，double

​	特性：

```
map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小
map：内部用红黑树实现，具有自动排序（按键从小到大）功能。
unordered_map：内部用哈希表实现，内部元素无序杂乱。
```

​	添加元素：

```
mp.insert(pair<string,string>("fruit","水果"));
mp.insert({"hahaha","wawawa"});
```

​	遍历访问：

```
//方式一：迭代器访问
map<string,string>::iterator it;
for(it = mp.begin(); it != mp.end(); it++) {
	//      键                 值 
	// it是结构体指针访问所以要用 -> 访问
	cout << it->first << " " << it->second << "\n";
	//*it是结构体变量 访问要用 . 访问
	//cout<<(*it).first<<" "<<(*it).second;
}

//方式二，智能指针访问
for(auto i : mp)
cout << i.first << " " << i.second << endl;//键，值

//方式二，对指定单个元素访问
map<char,int>::iterator it = mp.find('a');
cout << it -> first << " " <<  it->second << "\n";


//正向遍历
map<int,int> mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.begin();
while(it != mp.end()) {
	cout << it->first << " " << it->second << "\n";
	it ++;
}
```

方法：

```
mp.erase(key) //根据映射的键删除键和值
mp.size()	//返回映射的对数
mp.insert()	//插入元素，插入时要构造键值对
mp.empty()	//如果map为空，返回true，否则返回false
mp.count(key)	//查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0
mp.begin()：返回指向map第一个元素的迭代器（地址）
mp.end() //返回指向map尾部的迭代器（最后一个元素的下一个地址）
mp.find(key)	//返回键为key的映射的迭代器
注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()
```
